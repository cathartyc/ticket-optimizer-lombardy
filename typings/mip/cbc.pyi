"""
This type stub file was generated by pyright.
"""

import os
import numbers
import mip
from typing import List, Optional, Tuple, Union
from mip import Column, Constr, CutPool, CutType, LinExpr, Model, OptimizationStatus, SearchEmphasis, Solver, Var

"""Python-MIP interface to the COIN-OR Branch-and-Cut solver CBC"""
logger = ...
warningMessages = ...
ffi = ...
has_cbc = ...
os_is_64_bit = ...
INF = ...
cut_idx = ...
MAX_NAME_SIZE = ...
DEF_PUMPP = ...
pathmip = ...
pathlib = ...
libfile = ...
if "PMIP_CBC_LIBRARY" in os.environ:
    libfile = ...
    pathlib = ...
else:
    ...
old_dir = ...
cbclib = ...
has_cbc = ...
if has_cbc:
    ...
CHAR_ONE = ...
CHAR_ZERO = ...
DBL_PARAM_PRIMAL_TOL = ...
DBL_PARAM_DUAL_TOL = ...
DBL_PARAM_ZERO_TOL = ...
DBL_PARAM_INT_TOL = ...
DBL_PARAM_PRESOLVE_TOL = ...
DBL_PARAM_TIME_LIMIT = ...
DBL_PARAM_PSI = ...
DBL_PARAM_CUTOFF = ...
DBL_PARAM_ALLOWABLE_GAP = ...
DBL_PARAM_GAP_RATIO = ...
DBL_PARAM_MAX_SECS_NOT_IMPROV_FS = ...
INT_PARAM_PERT_VALUE = ...
INT_PARAM_IDIOT = ...
INT_PARAM_STRONG_BRANCHING = ...
INT_PARAM_CUT_DEPTH = ...
INT_PARAM_MAX_NODES = ...
INT_PARAM_NUMBER_BEFORE = ...
INT_PARAM_FPUMP_ITS = ...
INT_PARAM_MAX_SOLS = ...
INT_PARAM_CUT_PASS_IN_TREE = ...
INT_PARAM_THREADS = ...
INT_PARAM_CUT_PASS = ...
INT_PARAM_LOG_LEVEL = ...
INT_PARAM_MAX_SAVED_SOLS = ...
INT_PARAM_MULTIPLE_ROOTS = ...
INT_PARAM_ROUND_INT_VARS = ...
INT_PARAM_RANDOM_SEED = ...
INT_PARAM_ELAPSED_TIME = ...
INT_PARAM_CGRAPH = ...
INT_PARAM_CLIQUE_MERGING = ...
INT_PARAM_MAX_NODES_NOT_IMPROV_FS = ...
Osi_getNumCols = ...
Osi_getColSolution = ...
Osi_getIntegerTolerance = ...
Osi_isInteger = ...
Osi_isProvenOptimal = ...
Cbc_setIntParam = ...
Cbc_setDblParam = ...
Cbc_getSolverPtr = ...
Cbc_generateCuts = ...
Cbc_solveLinearProgram = ...
Cbc_reset = ...
Cbc_computeFeatures = ...
Cbc_nFeatures = ...
Cbc_featureName = ...
OsiCuts_new = ...
OsiCuts_addRowCut = ...
OsiCuts_addGlobalRowCut = ...
OsiCuts_sizeRowCuts = ...
OsiCuts_nzRowCut = ...
OsiCuts_idxRowCut = ...
OsiCuts_coefRowCut = ...
OsiCuts_rhsRowCut = ...
OsiCuts_senseRowCut = ...
OsiCuts_delete = ...
def cbc_set_parameter(model: Solver, param: str, value: str): # -> None:
    ...

class SolverCbc(Solver):
    def __init__(self, model: Model, name: str, sense: str) -> None:
        ...
    
    def add_var(self, obj: numbers.Real = ..., lb: numbers.Real = ..., ub: numbers.Real = ..., coltype: str = ..., column: Optional[Column] = ..., name: str = ...): # -> None:
        ...
    
    def update_conflict_graph(self: SolverCbc): # -> None:
        ...
    
    def cgraph_density(self: SolverCbc) -> float:
        ...
    
    def conflicting(self: SolverCbc, e1: Union[LinExpr, Var], e2: Union[LinExpr, Var]) -> bool:
        ...
    
    def conflicting_nodes(self: SolverCbc, v1: Union[Var, LinExpr]) -> Tuple[List[Var], List[Var]]:
        """Returns all assignment conflicting with the assignment in v1 in the
        conflict graph.
        """
        ...
    
    def get_objective_const(self) -> numbers.Real:
        ...
    
    def get_objective(self) -> LinExpr:
        ...
    
    def set_objective(self, lin_expr: LinExpr, sense: str = ...) -> None:
        ...
    
    def relax(self): # -> None:
        ...
    
    def get_max_seconds(self) -> numbers.Real:
        ...
    
    def set_max_seconds(self, max_seconds: numbers.Real): # -> None:
        ...
    
    def get_max_solutions(self) -> int:
        ...
    
    def set_max_solutions(self, max_solutions: int): # -> None:
        ...
    
    def get_max_nodes(self) -> int:
        ...
    
    def set_max_nodes(self, max_nodes: int): # -> None:
        ...
    
    def get_verbose(self) -> int:
        ...
    
    def set_verbose(self, verbose: int): # -> None:
        ...
    
    def var_set_var_type(self, var: Var, value: str): # -> None:
        ...
    
    def var_set_obj(self, var: Var, value: numbers.Real): # -> None:
        ...
    
    def generate_cuts(self, cut_types: Optional[List[CutType]] = ..., depth: int = ..., npass: int = ..., max_cuts: int = ..., min_viol: numbers.Real = ...) -> CutPool:
        ...
    
    def clique_merge(self, constrs: Optional[List[mip.Constr]] = ...): # -> None:
        ...
    
    def optimize(self, relax: bool = ...) -> OptimizationStatus:
        ...
    
    def get_objective_sense(self) -> str:
        ...
    
    def set_objective_sense(self, sense: str): # -> None:
        ...
    
    def get_objective_value(self) -> numbers.Real:
        ...
    
    def get_status(self) -> OptimizationStatus:
        ...
    
    def get_log(self) -> List[Tuple[numbers.Real, Tuple[numbers.Real, numbers.Real]]]:
        ...
    
    def get_objective_bound(self) -> numbers.Real:
        ...
    
    def var_get_x(self, var: Var) -> Optional[numbers.Real]:
        ...
    
    def get_num_solutions(self) -> int:
        ...
    
    def get_objective_value_i(self, i: int) -> numbers.Real:
        ...
    
    def var_get_xi(self, var: Var, i: int) -> numbers.Real:
        ...
    
    def var_get_rc(self, var: Var) -> numbers.Real:
        ...
    
    def var_get_lb(self, var: Var) -> numbers.Real:
        ...
    
    def var_set_lb(self, var: Var, value: numbers.Real): # -> None:
        ...
    
    def var_get_ub(self, var: Var) -> numbers.Real:
        ...
    
    def var_set_ub(self, var: Var, value: numbers.Real): # -> None:
        ...
    
    def var_get_name(self, idx: int) -> str:
        ...
    
    def var_get_index(self, name: str) -> int:
        ...
    
    def var_get_branch_priority(self, var: Var) -> numbers.Real:
        ...
    
    def constr_get_index(self, name: str) -> int:
        ...
    
    def constr_get_rhs(self, idx: int) -> numbers.Real:
        ...
    
    def constr_set_rhs(self, idx: int, rhs: numbers.Real): # -> None:
        ...
    
    def var_get_obj(self, var: Var) -> numbers.Real:
        ...
    
    def var_get_var_type(self, var: Var) -> str:
        ...
    
    def var_set_column(self, var: Var, value: Column):
        ...
    
    def var_get_column(self, var: Var) -> Column:
        ...
    
    def add_constr(self, lin_expr: LinExpr, name: str = ...): # -> None:
        ...
    
    def add_lazy_constr(self: Solver, lin_expr: LinExpr): # -> None:
        ...
    
    def add_sos(self, sos: List[Tuple[Var, numbers.Real]], sos_type: int): # -> None:
        ...
    
    def add_cut(self, lin_expr: LinExpr): # -> None:
        ...
    
    def write(self, file_path: str): # -> None:
        ...
    
    def read(self, file_path: str) -> None:
        ...
    
    def set_start(self, start: List[Tuple[Var, numbers.Real]]) -> None:
        ...
    
    def num_cols(self) -> int:
        ...
    
    def num_int(self) -> int:
        ...
    
    def num_rows(self) -> int:
        ...
    
    def num_nz(self) -> int:
        ...
    
    def get_cutoff(self) -> numbers.Real:
        ...
    
    def set_cutoff(self, cutoff: numbers.Real): # -> None:
        ...
    
    def get_mip_gap_abs(self) -> numbers.Real:
        ...
    
    def set_mip_gap_abs(self, allowable_gap: numbers.Real): # -> None:
        ...
    
    def get_mip_gap(self) -> numbers.Real:
        ...
    
    def set_mip_gap(self, allowable_ratio_gap: numbers.Real): # -> None:
        ...
    
    def constr_get_expr(self, constr: Constr) -> LinExpr:
        ...
    
    def constr_get_name(self, idx: int) -> str:
        ...
    
    def set_processing_limits(self: Solver, max_time: numbers.Real = ..., max_nodes: int = ..., max_sol: int = ..., max_seconds_same_incumbent: int = ..., max_nodes_same_incumbent: float = ...): # -> None:
        ...
    
    def get_emphasis(self) -> SearchEmphasis:
        ...
    
    def set_emphasis(self, emph: SearchEmphasis): # -> None:
        ...
    
    def set_num_threads(self, threads: int): # -> None:
        ...
    
    def remove_constrs(self, constrs: List[int]): # -> None:
        ...
    
    def remove_vars(self, varsList: List[int]): # -> None:
        ...
    
    def __del__(self): # -> None:
        ...
    
    def get_problem_name(self) -> str:
        ...
    
    def set_problem_name(self, name: str): # -> None:
        ...
    
    def get_pump_passes(self) -> int:
        ...
    
    def set_pump_passes(self, passes: int): # -> None:
        ...
    
    def constr_get_pi(self, constr: Constr) -> Optional[numbers.Real]:
        ...
    
    def constr_get_slack(self, constr: Constr) -> Optional[numbers.Real]:
        ...
    
    def feature_values(self) -> List[float]:
        ...
    
    def reset(self): # -> None:
        ...
    


def feature_names() -> List[str]:
    ...

class ModelOsi(Model):
    def __init__(self, osi_ptr) -> None:
        ...
    
    def add_constr(self, lin_expr: LinExpr, name: str = ...) -> Constr:
        ...
    


class SolverOsi(Solver):
    """Interface for the OsiSolverInterface, the generic solver interface of
    COIN-OR. This solver has a restricted functionality (comparing to
    SolverCbc) and it is used mainly in callbacks where only the pre-processed
    model is available"""
    def __init__(self, model: Model, osi_ptr=...) -> None:
        ...
    
    def __del__(self): # -> None:
        ...
    
    def add_var(self, name: str = ..., obj: numbers.Real = ..., lb: numbers.Real = ..., ub: numbers.Real = ..., var_type: str = ..., column: Column = ...): # -> None:
        ...
    
    def add_constr(self, lin_expr: LinExpr, name: str = ...): # -> None:
        ...
    
    def add_cut(self, lin_expr: LinExpr): # -> None:
        ...
    
    def add_lazy_constr(self, lin_expr: LinExpr): # -> None:
        ...
    
    def get_objective_bound(self) -> numbers.Real:
        ...
    
    def get_objective(self) -> LinExpr:
        ...
    
    def get_objective_const(self) -> numbers.Real:
        ...
    
    def relax(self): # -> None:
        ...
    
    def optimize(self) -> OptimizationStatus:
        ...
    
    def get_status(self) -> OptimizationStatus:
        ...
    
    def get_objective_value(self) -> numbers.Real:
        ...
    
    def get_log(self) -> List[Tuple[numbers.Real, Tuple[numbers.Real, numbers.Real]]]:
        ...
    
    def get_objective_value_i(self, i: int) -> numbers.Real:
        ...
    
    def get_num_solutions(self) -> int:
        ...
    
    def get_objective_sense(self) -> str:
        ...
    
    def set_objective_sense(self, sense: str): # -> None:
        ...
    
    def set_start(self, start: List[Tuple[Var, numbers.Real]]):
        ...
    
    def set_objective(self, lin_expr: LinExpr, sense: str = ...): # -> None:
        ...
    
    def set_objective_const(self, const: numbers.Real):
        ...
    
    def set_processing_limits(self, max_time: numbers.Real = ..., max_nodes: int = ..., max_sol: int = ...):
        ...
    
    def get_max_seconds(self) -> numbers.Real:
        ...
    
    def set_max_seconds(self, max_seconds: numbers.Real):
        ...
    
    def get_max_solutions(self) -> int:
        ...
    
    def set_max_solutions(self, max_solutions: int):
        ...
    
    def get_pump_passes(self) -> int:
        ...
    
    def set_pump_passes(self, passes: int):
        ...
    
    def get_max_nodes(self) -> int:
        ...
    
    def set_max_nodes(self, max_nodes: int):
        ...
    
    def set_num_threads(self, threads: int):
        ...
    
    def write(self, file_path: str):
        ...
    
    def read(self, file_path: str):
        ...
    
    def num_cols(self) -> int:
        ...
    
    def num_rows(self) -> int:
        ...
    
    def num_nz(self) -> int:
        ...
    
    def num_int(self) -> int:
        ...
    
    def get_emphasis(self) -> SearchEmphasis:
        ...
    
    def set_emphasis(self, emph: SearchEmphasis):
        ...
    
    def get_cutoff(self) -> numbers.Real:
        ...
    
    def set_cutoff(self, cutoff: numbers.Real):
        ...
    
    def get_mip_gap_abs(self) -> numbers.Real:
        ...
    
    def set_mip_gap_abs(self, mip_gap_abs: numbers.Real):
        ...
    
    def get_mip_gap(self) -> numbers.Real:
        ...
    
    def set_mip_gap(self, mip_gap: numbers.Real):
        ...
    
    def get_verbose(self) -> int:
        ...
    
    def set_verbose(self, verbose: int):
        ...
    
    def constr_get_expr(self, constr: Constr) -> LinExpr:
        ...
    
    def constr_set_expr(self, constr: Constr, value: LinExpr) -> LinExpr:
        ...
    
    def constr_get_name(self, idx: int) -> str:
        ...
    
    def remove_constrs(self, constrsList: List[int]):
        ...
    
    def constr_get_index(self, name: str) -> int:
        ...
    
    def constr_get_pi(self, constr: Constr) -> Optional[numbers.Real]:
        ...
    
    def constr_get_slack(self, constr: Constr) -> Optional[float]:
        ...
    
    def var_get_branch_priority(self, var: Var) -> numbers.Real:
        ...
    
    def var_set_branch_priority(self, var: Var, value: numbers.Real):
        ...
    
    def var_get_lb(self, var: Var) -> numbers.Real:
        ...
    
    def var_set_lb(self, var: Var, value: numbers.Real): # -> None:
        ...
    
    def var_get_ub(self, var: Var) -> numbers.Real:
        ...
    
    def var_set_ub(self, var: Var, value: numbers.Real): # -> None:
        ...
    
    def var_get_obj(self, var: Var) -> numbers.Real:
        ...
    
    def var_set_obj(self, var: Var, value: numbers.Real): # -> None:
        ...
    
    def var_get_var_type(self, var: Var) -> str:
        ...
    
    def var_set_var_type(self, var: Var, value: str): # -> None:
        ...
    
    def var_get_column(self, var: Var) -> Column:
        ...
    
    def var_set_column(self, var: Var, value: Column):
        ...
    
    def var_get_rc(self, var: Var) -> numbers.Real:
        ...
    
    def var_get_x(self, var: Var) -> numbers.Real:
        ...
    
    def var_get_xi(self, var: Var, i: int) -> numbers.Real:
        ...
    
    def var_get_name(self, idx: int) -> str:
        ...
    
    def remove_vars(self, varsList: List[int]):
        ...
    
    def var_get_index(self, name: str) -> int:
        ...
    
    def get_problem_name(self) -> str:
        ...
    
    def set_problem_name(self, name: str):
        ...
    


