"""
This type stub file was generated by pyright.
"""

import numbers
import mip
from . import  LinExpr, Real, Var
from .constants import ConstraintPriority
from builtins import property
from typing import Dict, List, Optional, Tuple, Union, override

class Column:
    """A column contains all the non-zero entries of a variable in the
    constraint matrix. To create a variable see
    :meth:`~mip.Model.add_var`."""
    __slots__ = ...
    def __init__(self, constrs=..., coeffs: Optional[List[numbers.Real]] = ...) -> None:
        ...
    
    def __str__(self) -> str:
        ...
    


class LinExpr:
    """
    Linear expressions are used to enter the objective function and the model \
    constraints. These expressions are created using operators and variables.

    Consider a model object m, the objective function of :code:`m` can be
    specified as:

    .. code:: python

     m.objective = 10*x1 + 7*x4

    In the example bellow, a constraint is added to the model

    .. code:: python

     m += xsum(3*x[i] i in range(n)) - xsum(x[i] i in range(m))

    A constraint is just a linear expression with the addition of a sense (==,
    <= or >=) and a right hand side, e.g.:

    .. code:: python

     m += x1 + x2 + x3 == 1

    If used in intermediate calculations, the solved value of the linear
    expression can be obtained with the ``x`` parameter, just as with
    a ``Var``.

    .. code:: python

     a = 10*x1 + 7*x4
     print(a.x)

    """
    __slots__ = ...
    def __init__(self, variables: Optional[List[Var]] = ..., coeffs: Optional[List[numbers.Real]] = ..., const: numbers.Real = ..., sense: str = ..., expr: Optional[Dict[Var, numbers.Real]] = ...) -> None:
        ...
    
    def __add__(self, other: Union[Var, LinExpr, numbers.Real]) -> LinExpr:
        ...
    
    def __radd__(self, other: Union[Var, LinExpr, numbers.Real]) -> LinExpr:
        ...
    
    def __sub__(self, other: Union[Var, LinExpr, numbers.Real]) -> LinExpr:
        ...
    
    def __rsub__(self, other: Union[Var, LinExpr, numbers.Real]) -> LinExpr:
        ...
    
    def __mul__(self, other: numbers.Real) -> LinExpr:
        ...
    
    def __rmul__(self, other: numbers.Real) -> LinExpr:
        ...
    
    def __truediv__(self, other: numbers.Real) -> LinExpr:
        ...
    
    def __neg__(self) -> LinExpr:
        ...
    
    def __str__(self) -> str:
        ...
    
    def __eq__(self, other) -> LinExpr:
        ...
    
    def __le__(self, other: Union[Var, LinExpr, numbers.Real]) -> LinExpr:
        ...
    
    def __ge__(self, other: Union[Var, LinExpr, numbers.Real]) -> LinExpr:
        ...
    
    def __len__(self): # -> int:
        ...
    
    def add_const(self, val: numbers.Real): # -> None:
        """adds a constant value to the linear expression, in the case of
        a constraint this corresponds to the right-hand-side

        Args:
            val(numbers.Real): a real number
        """
        ...
    
    def add_expr(self, expr: LinExpr, coeff: numbers.Real = ...) -> None: # -> None:
        """Extends a linear expression with the contents of another.

        Args:
            expr (LinExpr): another linear expression
            coeff (numbers.Real): coefficient which will multiply the linear
                expression added
        """
        ...
    
    def add_term(self, term: Union[Var, LinExpr, numbers.Real], coeff: numbers.Real = ...) -> None: # -> None:
        """Adds a term to the linear expression.

        Args:
            term (Union[Var, LinExpr, numbers.Real]) : can be a
                variable, another linear expression or a real number.

            coeff (numbers.Real) : coefficient which will multiply the added
                term

        """
        ...
    
    def add_var(self, var: Var, coeff: numbers.Real = ...) -> None: # -> None:
        """Adds a variable with a coefficient to the linear expression.

        Args:
            var (Var) : a variable
            coeff (numbers.Real) : coefficient which the variable will be added
        """
        ...
    
    def set_expr(self: LinExpr, expr: Dict[Var, numbers.Real]) -> None: # -> None:
        """Sets terms of the linear expression

        Args:
            expr(Dict[Var, numbers.Real]) : dictionary mapping variables to
                their coefficients in the linear expression.
        """
        ...
    
    def copy(self) -> LinExpr:
        ...
    
    def equals(self, other: LinExpr) -> bool:
        """returns true if a linear expression equals to another,
        false otherwise"""
        ...
    
    @override
    def __hash__(self) -> int:
        ...
    
    @property
    def const(self) -> numbers.Real:
        """constant part of the linear expression"""
        ...
    
    @property
    def expr(self) -> Dict[Var, numbers.Real]:
        """the non-constant part of the linear expression

        Dictionary with pairs: (variable, coefficient) where coefficient
        is a real number.

        :rtype: Dict[Var, numbers.Real]
        """
        ...
    
    @property
    def sense(self) -> str:
        """sense of the linear expression

        sense can be EQUAL("="), LESS_OR_EQUAL("<"), GREATER_OR_EQUAL(">") or
        empty ("") if this is an affine expression, such as the objective
        function
        """
        ...
    
    @sense.setter
    def sense(self, value) -> None: # -> None:
        """sense of the linear expression

        sense can be EQUAL("="), LESS_OR_EQUAL("<"), GREATER_OR_EQUAL(">") or
        empty ("") if this is an affine expression, such as the objective
        function
        """
        ...
    
    @property
    def violation(self) -> Optional[numbers.Real]:
        """Amount that current solution violates this constraint

        If a solution is available, than this property indicates how much
        the current solution violates this constraint.
        """
        ...
    
    @property
    def x(self) -> Optional[numbers.Real]:
        """Value of this linear expression in the solution. None
        is returned if no solution is available."""
        ...
    
    def __float__(self) -> float: # -> float:
        ...
    
    @property
    def model(self) -> Optional[mip.Model]:
        """Model which this LinExpr refers to, None if no variables are
        involved.

        :rtype: Optional[mip.Model]
        """
        ...
    


class Constr:
    """A row (constraint) in the constraint matrix.

    A constraint is a specific :class:`~LinExpr` that includes a
    sense (<, > or == or less-or-equal, greater-or-equal and equal,
    respectively) and a right-hand-side constant value. Constraints can be
    added to the model using the overloaded operator :code:`+=` or using
    the method :meth:`~mip.Model.add_constr` of the
    :class:`~mip.Model` class:

    .. code:: python

      m += 3*x1 + 4*x2 <= 5

    summation expressions are also supported:

    .. code:: python

      m += xsum(x[i] for i in range(n)) == 1
    """
    __slots__: list[str] = ...
    def __init__(self, model: mip.Model, idx: int, priority: ConstraintPriority = ...) -> None:
        ...
    
    def __hash__(self) -> int:
        ...
    
    def __str__(self) -> str:
        ...
    
    @property
    def rhs(self) -> numbers.Real:
        """The right-hand-side (constant value) of the linear constraint."""
        ...
    
    @rhs.setter
    def rhs(self, rhs: numbers.Real): # -> None:
        ...
    
    @property
    def slack(self) -> Optional[numbers.Real]:
        """Value of the slack in this constraint in the optimal
        solution. Available only if the formulation was solved.
        """
        ...
    
    @property
    def pi(self) -> Optional[numbers.Real]:
        """Value for the dual variable of this constraint in the optimal
        solution of a linear programming :class:`~mip.Model`. Only
        available if a pure linear programming problem was solved (only
        continuous variables).
        """
        ...
    
    @property
    def expr(self) -> LinExpr:
        """Linear expression that defines the constraint.

        :rtype: LinExpr"""
        ...
    
    @expr.setter
    def expr(self, value: LinExpr) -> None: # -> None:
        ...
    
    @property
    def name(self) -> str:
        """constraint name"""
        ...
    
    @property
    def priority(self) -> ConstraintPriority:
        """priority value"""
        ...
    
    @priority.setter
    def priority(self, priority: ConstraintPriority) -> None: # -> None:
        ...
    


class Var:
    """Decision variable of the :class:`~mip.Model`. The creation of
    variables is performed calling the :meth:`~mip.Model.add_var`."""
    __slots__: list[str] = ...
    def __init__(self, model: mip.Model, idx: int) -> None:
        ...
    
    @override
    def __hash__(self) -> int:
        ...
    
    def __add__(self, other: Union[Var, LinExpr, numbers.Real]) -> Union[Var, LinExpr]:
        ...
    
    def __radd__(self, other: Union[Var, LinExpr, numbers.Real]) -> Union[Var, LinExpr]:
        ...
    
    def __sub__(self, other: Union[Var, LinExpr, numbers.Real]) -> Union[Var, LinExpr]:
        ...
    
    def __rsub__(self, other: Union[Var, LinExpr, numbers.Real]) -> Union[Var, LinExpr]:
        ...
    
    def __mul__(self, other: numbers.Real) -> LinExpr:
        ...
    
    def __rmul__(self, other: numbers.Real) -> LinExpr:
        ...
    
    def __truediv__(self, other: numbers.Real) -> LinExpr:
        ...
    
    def __neg__(self) -> LinExpr:
        ...
    
    @override
    def __eq__(self, other) -> LinExpr:
        ...
    
    def __le__(self, other: Union[Var, LinExpr, numbers.Real]) -> LinExpr:
        ...
    
    def __ge__(self, other: Union[Var, LinExpr, numbers.Real]) -> LinExpr:
        ...
    
    @property
    def name(self) -> str:
        """Variable name."""
        ...
    
    @override
    def __str__(self) -> str:
        ...
    
    @property
    def lb(self) -> numbers.Real:
        """Variable lower bound."""
        ...
    
    @lb.setter
    def lb(self, value: numbers.Real): # -> None:
        ...
    
    @property
    def ub(self) -> numbers.Real:
        """Variable upper bound."""
        ...
    
    @ub.setter
    def ub(self, value: numbers.Real): # -> None:
        ...
    
    @property
    def obj(self) -> numbers.Real:
        """Coefficient of variable in the objective function."""
        ...
    
    @obj.setter
    def obj(self, value: numbers.Real): # -> None:
        ...
    
    @property
    def branch_priority(self) -> numbers.Real:
        """
        Variable's branching priority in the branch and bound process.
        Note: variables with higher priority are selected first. Default value is zero.
        """
        ...
    
    @branch_priority.setter
    def branch_priority(self, value: numbers.Real): # -> None:
        ...
    
    @property
    def var_type(self) -> str:
        """Variable type, ('B') BINARY, ('C') CONTINUOUS and ('I') INTEGER."""
        ...
    
    @var_type.setter
    def var_type(self, value: str): # -> None:
        ...
    
    @property
    def column(self) -> Column:
        """Variable coefficients in constraints.

        :rtype: mip.Column
        """
        ...
    
    @column.setter
    def column(self, value: Column): # -> None:
        ...
    
    @property
    def rc(self) -> Optional[numbers.Real]:
        """Reduced cost, only available after a linear programming model (only
        continuous variables) is optimized. Note that None is returned if no
        optimum solution is available"""
        ...
    
    @property
    def x(self) -> Optional[numbers.Real]:
        """Value of this variable in the solution. Note that None is returned
        if no solution is not available."""
        ...
    
    def xi(self, i: int) -> Optional[numbers.Real]:
        """Value for this variable in the :math:`i`-th solution from the solution
        pool. Note that None is returned if the solution is not available."""
        ...
    
    def __float__(self): # -> float:
        ...
    
    @property
    def model(self) -> mip.Model:
        """Model which this variable refers to.

        :rtype: mip.Model
        """
        ...
    
    @property
    def idx(self) -> int:
        """Internal index of the variable to the model.

        :rtype: int
        """
        ...
    


class ConflictGraph:
    r"""A conflict graph stores conflicts between incompatible assignments in
    binary variables.

    For example, if there is a constraint :math:`x_1 + x_2 \leq 1` then
    there is a conflict between :math:`x_1 = 1` and :math:`x_2 = 1`. We can state
    that :math:`x_1` and :math:`x_2` are conflicting. Conflicts can also involve the complement
    of a binary variable. For example, if there is a constraint :math:`x_1 \leq
    x_2` then there is a conflict between :math:`x_1 = 1` and :math:`x_2 = 0`.
    We now can state that :math:`x_1` and :math:`\lnot x_2` are conflicting."""
    __slots__ = ...
    def __init__(self, model: mip.Model) -> None:
        ...
    
    @property
    def density(self) -> float:
        ...
    
    def conflicting(self, e1: Union[LinExpr, Var], e2: Union[LinExpr, Var]) -> bool:
        """Checks if two assignments of binary variables are in conflict.

        Args:
            e1 (Union[LinExpr, Var]): binary variable, if assignment to be
                tested is the assignment to one, or a linear expression like x == 0
                to indicate that conflict with the complement of the variable
                should be tested.

            e2 (Union[LinExpr, Var]): binary variable, if assignment to be
                tested is the assignment to one, or a linear expression like x == 0
                to indicate that conflict with the complement of the variable
                should be tested.
        """
        ...
    
    def conflicting_assignments(self, v: Union[LinExpr, Var]) -> Tuple[List[Var], List[Var]]:
        """Returns from the conflict graph all assignments conflicting with one
        specific assignment.

        Args:
            v (Union[Var, LinExpr]): binary variable, if assignment to be
                tested is the assignment to one or a linear expression like x == 0
                to indicate the complement.

        :rtype: Tuple[List[Var], List[Var]]

        Returns:
            Returns a tuple with two lists. The first one indicates variables
            whose conflict occurs when setting them to one. The second list
            includes variable whose conflict occurs when setting them to zero.
        """
        ...
    


