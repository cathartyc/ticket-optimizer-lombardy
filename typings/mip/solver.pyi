"""
This type stub file was generated by pyright.
"""

import numbers
import mip
from typing import List, Optional, Tuple, Union

"""This module implements the solver intependent communication layer of
Python-MIP
"""
class Solver:
    """The solver is an abstract class with the solver independent
    API to communicate with the solver engine"""
    def __init__(self: Solver, model: Model, name: str = ..., sense: str = ...) -> None:
        ...
    
    def __del__(self: Solver): # -> None:
        ...
    
    def add_var(self: Solver, name: str = ..., obj: numbers.Real = ..., lb: numbers.Real = ..., ub: numbers.Real = ..., var_type: str = ..., column: Column = ...): # -> None:
        ...
    
    def add_constr(self: Solver, lin_expr: mip.LinExpr, name: str = ...): # -> None:
        ...
    
    def add_lazy_constr(self: Solver, lin_expr: mip.LinExpr): # -> None:
        ...
    
    def add_sos(self: Solver, sos: List[Tuple[mip.Var, numbers.Real]], sos_type: int): # -> None:
        ...
    
    def add_cut(self: Solver, lin_expr: mip.LinExpr): # -> None:
        ...
    
    def get_objective_bound(self: Solver) -> numbers.Real:
        ...
    
    def get_objective(self: Solver) -> mip.LinExpr:
        ...
    
    def get_objective_const(self: Solver) -> numbers.Real:
        ...
    
    def relax(self: Solver): # -> None:
        ...
    
    def generate_cuts(self, cut_types: Optional[List[mip.CutType]] = ..., depth: int = ..., npass: int = ..., max_cuts: int = ..., min_viol: numbers.Real = ...) -> mip.CutPool:
        ...
    
    def clique_merge(self, constrs: Optional[List[mip.Constr]] = ...): # -> None:
        ...
    
    def optimize(self: Solver, relax: bool = ...) -> mip.OptimizationStatus:
        ...
    
    def get_objective_value(self: Solver) -> numbers.Real:
        ...
    
    def get_log(self: Solver) -> List[Tuple[numbers.Real, Tuple[numbers.Real, numbers.Real]]]:
        ...
    
    def get_objective_value_i(self: Solver, i: int) -> numbers.Real:
        ...
    
    def get_num_solutions(self: Solver) -> int:
        ...
    
    def get_objective_sense(self: Solver) -> str:
        ...
    
    def set_objective_sense(self: Solver, sense: str): # -> None:
        ...
    
    def set_start(self: Solver, start: List[Tuple[mip.Var, numbers.Real]]): # -> None:
        ...
    
    def set_objective(self: Solver, lin_expr: mip.LinExpr, sense: str = ...): # -> None:
        ...
    
    def set_objective_const(self: Solver, const: numbers.Real): # -> None:
        ...
    
    def set_processing_limits(self: Solver, max_time: numbers.Real = ..., max_nodes: int = ..., max_sol: int = ..., max_seconds_same_incumbent: float = ..., max_nodes_same_incumbent: int = ...): # -> None:
        ...
    
    def get_max_seconds(self: Solver) -> numbers.Real:
        ...
    
    def set_max_seconds(self: Solver, max_seconds: numbers.Real): # -> None:
        ...
    
    def get_max_solutions(self: Solver) -> int:
        ...
    
    def set_max_solutions(self: Solver, max_solutions: int): # -> None:
        ...
    
    def get_pump_passes(self: Solver) -> int:
        ...
    
    def set_pump_passes(self: Solver, passes: int): # -> None:
        ...
    
    def get_max_nodes(self: Solver) -> int:
        ...
    
    def set_max_nodes(self: Solver, max_nodes: int): # -> None:
        ...
    
    def set_num_threads(self: Solver, threads: int): # -> None:
        ...
    
    def write(self: Solver, file_path: str): # -> None:
        ...
    
    def read(self: Solver, file_path: str): # -> None:
        ...
    
    def num_cols(self: Solver) -> int:
        ...
    
    def num_rows(self: Solver) -> int:
        ...
    
    def num_nz(self: Solver) -> int:
        ...
    
    def num_int(self: Solver) -> int:
        ...
    
    def get_emphasis(self: Solver) -> mip.SearchEmphasis:
        ...
    
    def set_emphasis(self: Solver, emph: mip.SearchEmphasis): # -> None:
        ...
    
    def get_cutoff(self: Solver) -> numbers.Real:
        ...
    
    def set_cutoff(self: Solver, cutoff: numbers.Real): # -> None:
        ...
    
    def get_mip_gap_abs(self: Solver) -> numbers.Real:
        ...
    
    def set_mip_gap_abs(self: Solver, mip_gap_abs: numbers.Real): # -> None:
        ...
    
    def get_mip_gap(self: Solver) -> numbers.Real:
        ...
    
    def set_mip_gap(self: Solver, mip_gap: numbers.Real): # -> None:
        ...
    
    def get_verbose(self: Solver) -> int:
        ...
    
    def set_verbose(self: Solver, verbose: int): # -> None:
        ...
    
    def constr_get_expr(self: Solver, constr: mip.Constr) -> mip.LinExpr:
        ...
    
    def constr_set_expr(self: Solver, constr: mip.Constr, value: mip.LinExpr) -> mip.LinExpr:
        ...
    
    def constr_get_rhs(self: Solver, idx: int) -> numbers.Real:
        ...
    
    def constr_set_rhs(self: Solver, idx: int, rhs: numbers.Real): # -> None:
        ...
    
    def constr_get_name(self: Solver, idx: int) -> str:
        ...
    
    def constr_get_pi(self: Solver, constr: mip.Constr) -> numbers.Real:
        ...
    
    def constr_get_slack(self: Solver, constr: mip.Constr) -> numbers.Real:
        ...
    
    def remove_constrs(self: Solver, constrsList: List[int]): # -> None:
        ...
    
    def constr_get_index(self: Solver, name: str) -> int:
        ...
    
    def var_get_branch_priority(self: Solver, var: mip.Var) -> numbers.Real:
        ...
    
    def var_set_branch_priority(self: Solver, var: mip.Var, value: numbers.Real): # -> None:
        ...
    
    def var_get_lb(self: Solver, var: mip.Var) -> numbers.Real:
        ...
    
    def var_set_lb(self: Solver, var: mip.Var, value: numbers.Real): # -> None:
        ...
    
    def var_get_ub(self: Solver, var: mip.Var) -> numbers.Real:
        ...
    
    def var_set_ub(self: Solver, var: mip.Var, value: numbers.Real): # -> None:
        ...
    
    def var_get_obj(self: Solver, var: mip.Var) -> numbers.Real:
        ...
    
    def var_set_obj(self: Solver, var: mip.Var, value: numbers.Real): # -> None:
        ...
    
    def var_get_var_type(self: Solver, var: mip.Var) -> str:
        ...
    
    def var_set_var_type(self: Solver, var: mip.Var, value: str): # -> None:
        ...
    
    def var_get_column(self: Solver, var: mip.Var) -> Column:
        ...
    
    def var_set_column(self: Solver, var: mip.Var, value: Column): # -> None:
        ...
    
    def var_get_rc(self: Solver, var: mip.Var) -> numbers.Real:
        ...
    
    def var_get_x(self: Solver, var: mip.Var) -> numbers.Real:
        """Assumes that the solution is available (should be checked
        before calling it"""
        ...
    
    def var_get_xi(self: Solver, var: mip.Var, i: int) -> numbers.Real:
        ...
    
    def var_get_name(self: Solver, idx: int) -> str:
        ...
    
    def remove_vars(self: Solver, varsList: List[int]): # -> None:
        ...
    
    def var_get_index(self: Solver, name: str) -> int:
        ...
    
    def get_problem_name(self: Solver) -> str:
        ...
    
    def set_problem_name(self: Solver, name: str): # -> None:
        ...
    
    def get_status(self: Solver) -> mip.OptimizationStatus:
        ...
    
    def cgraph_density(self: Solver) -> float:
        """Density of the conflict graph"""
        ...
    
    def conflicting(self: Solver, e1: Union[mip.LinExpr, mip.Var], e2: Union[mip.LinExpr, mip.Var]) -> bool:
        """Checks if two assignment to binary variables are in conflict,
        returns none if no conflict graph is available"""
        ...
    
    def conflicting_nodes(self: Solver, v1: Union[mip.Var, mip.LinExpr]) -> Tuple[List[mip.Var], List[mip.Var]]:
        """Returns all assignment conflicting with the assignment in v1 in the
        conflict graph.
        """
        ...
    
    def feature_values(self: Solver) -> List[float]:
        ...
    
    def feature_names(self: Solver) -> List[str]:
        ...
    


